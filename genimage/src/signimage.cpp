/* Sign a firmware binary image for the RigDFU bootloader */

#include <cryptopp/osrng.h>
#include <cryptopp/aes.h>
#include <cryptopp/eax.h>
#include <cryptopp/channels.h>
#include <cryptopp/hex.h>

#include <stdio.h>
#include <stdint.h>
#include <stdarg.h>

typedef struct {
        uint8_t header[12];
        uint8_t iv[16];
        uint8_t tag[16];
} binfile_metadata_t;

uint32_t get_le32(uint8_t *src)
{
        return ((uint32_t)src[3] << 24) | ((uint32_t)src[2] << 16) |
                ((uint32_t)src[1] << 8) | (uint32_t)src[0];
}

bool is_zeros(uint8_t *buffer, int len)
{
        while (len--)
                if (*buffer++ != 0)
                        return false;
        return true;
}

void err(const char *fmt, ...)
{
        va_list ap;
        va_start(ap, fmt);
        vfprintf(stderr, fmt, ap);
        va_end(ap);
        exit(1);
}

int main(int argc, char *argv[])
{
        FILE *in, *out;
        binfile_metadata_t meta;
        int len;
        int i;
        uint8_t *data;
        uint8_t junk;
        uint8_t key[16];

        if (argc != 4) {
                fprintf(stderr, "usage: %s <input.bin> <output.bin> <key>\n",
                        *argv);
                fprintf(stderr, "  <input.bin> must be an unencrypted image, "
                        "as generated by genimage\n");
                fprintf(stderr, "  <key> is 32 hex characters, e.g.: "
                        "00112233445566778899aabbccddeeff\n");
                exit(1);
        }

        char *arg_in = argv[1];
        char *arg_out = argv[2];
        char *arg_key = argv[3];

        /* Parse key */
        CryptoPP::HexDecoder decoder;
        decoder.Put((byte *)arg_key, strlen(arg_key));
        decoder.MessageEnd();
        if (decoder.MaxRetrievable() != 16)
                err("error: key must be 16 bytes (32 hex characters)");
        decoder.Get(key, 16);

        /* Open file and read meta header */
        if ((in = fopen(arg_in, "rb")) == NULL)
                err("open %s failed", arg_in);
        if (fread(&meta, sizeof(meta), 1, in) != 1)
                err("failed to read meta");

        /* Total length is sd_len + bl_len + app_len; read file */
        len = get_le32(&meta.header[0]) + get_le32(&meta.header[4]) +
                get_le32(&meta.header[8]);
        data = new uint8_t[len];
        if (fread(data, len, 1, in) != 1)
                err("failed to read %d bytes of image data", len);
        if (fread(&junk, 1, 1, in) != 0)
                err("extraneous data at end of file");
        fclose(in);

        /* Make sure it appears unencrypted */
        if (!is_zeros(meta.iv, sizeof(meta.iv)) ||
            !is_zeros(meta.tag, sizeof(meta.tag)))
                err("IV or tag != 0; is the input already encrypted?");

        /* Generate a new IV */
        CryptoPP::AutoSeededRandomPool rng;
        rng.GenerateBlock(meta.iv, sizeof(meta.iv));

        /* Set up encryption */
        CryptoPP::EAX<CryptoPP::AES>::Encryption e;
        e.SetKeyWithIV(key, sizeof(key), meta.iv, sizeof(meta.iv));
        std::string ciphertext, tag;
        CryptoPP::StringSink ciphertextSink(ciphertext), tagSink(tag);
        CryptoPP::ChannelSwitch *cs;
        cs = new CryptoPP::ChannelSwitch(ciphertextSink);
        cs->AddRoute("TAG", tagSink, CryptoPP::DEFAULT_CHANNEL);
        CryptoPP::AuthenticatedEncryptionFilter ef(e, cs, false, -1, "TAG");

        /* Add header and data */
        ef.ChannelPut(CryptoPP::AAD_CHANNEL, meta.header, sizeof(meta.header));
        ef.ChannelMessageEnd(CryptoPP::AAD_CHANNEL);
        ef.ChannelPut(CryptoPP::DEFAULT_CHANNEL, data, len);
        ef.ChannelMessageEnd(CryptoPP::DEFAULT_CHANNEL);

        /* Check result */
        if (ciphertext.size() != len)
                err("expected ciphertext size %d, got %d\n", len,
                     ciphertext.size());
        if (tag.size() != sizeof(meta.tag))
                err("expected tag size %d, got %d\n", sizeof(meta.tag),
                     tag.size());

        /* Put tag into metadata and write output */
        memcpy(&meta.tag, tag.data(), sizeof(meta.tag));
        if ((out = fopen(arg_out, "wb")) == NULL)
                err("open %s failed", arg_out);
        if (fwrite(&meta, sizeof(meta), 1, out) != 1)
                err("write failed");
        if (fwrite(ciphertext.data(), len, 1, out) != 1)
                err("write failed");
        if (fclose(out) != 0)
                err("close failed");

        return 0;
}
